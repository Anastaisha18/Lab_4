# Вавилина Настя ИТ-7 Лабораторная №4

# Задание 1.1

### Текст задачи 
Обобщенная коробка.  
Создайте сущность Коробка, которая обладает следующими характеристиками:  
• Может хранить один произвольный объект в один момент времени.  
• Объект можно получить и разместить на хранение в любой момент времени.  
• Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.  
• Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.  
• Имеет метод проверки на заполненность.  
• Методы класса должны работать с тем типом данных, который был указан во время  
создания объекта  
Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3.  
Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.  

### Алгоритм решения
1. Создаем обобщенный класс Box<T> с приватным полем T item  
2. Реализуем конструктор по умолчанию (item = null)  
3. Метод put(T item): если коробка не пуста (isFull()), выбрасываем IllegalStateException, 
иначе сохраняем объект  
4. Метод take(): если коробка пуста, возвращаем null, иначе сохраняем значение во временную  
переменную, обнуляем поле и возвращаем сохраненное значение  
5. Вспомогательные методы: isEmpty(), isFull(), peek()  
6. Демонстрация: создаем Box<Integer>, кладем число 3, передаем в метод, извлекаем и выводим  

### Тест



# Задание 1.2
### Текст задачи  
Без null.  
Создайте сущность Хранилище, которая обладает следующими характеристиками:  
• Может хранить один произвольный объект в один момент времени.  
• Хранилище неизменяемо.  
• Объект кладется в Хранилище при его создании. В качестве объекта может быть  
сохранено также и значение null.  
• Хранилище может вернуть ссылку на Объект.  
• Если вместо объекта хранится null, необходимо вернуть какое-либо альтернативное  
значение.  
• Метод получения значения должен работать с тем типом данных, который был указан во  
время создания объекта  
Выполните следующие задания:  
• Создайте Хранилище чисел, положите туда значение null. Передайте Хранилище в какойлибо метод,  
извлеките значение, и выведите его на экран. Альтернативой должно быть число 0.  
• Создайте Хранилище чисел, положите туда значение 99. Передайте Хранилище в какойлибо метод,  
извлеките значение, и выведите его на экран. Альтернативой должно бытьчисло -1.  
• Создайте Хранилище строк, положите туда значение null. Передайте Хранилище в какойлибо метод,  
извлеките значение, и выведите его на экран. Альтернативой должна бытьстрока “default”.  
• Создайте Хранилище строк, положите туда значение “hello”. Передайте Хранилище в  
какой-либо метод, извлеките значение, и выведите его на экран. Альтернативой должна  
быть строка “hello world”.  

### Алгоритм решения  
1. Создаем обобщенный класс Storage<T> с приватным final полем T item (неизменяемость)  
2. Конструктор принимает и сохраняет объект (может быть null)  
3. Метод getOrDefault(T defaultValue): если item != null, возвращаем item,  
иначе возвращаем defaultValue  
4. Демонстрируем 4 случая:  
- Storage<Integer> с null → альтернатива 0  
- Storage<Integer> с 99 → альтернатива -1  
- Storage<String> с null → альтернатива "default"  
- Storage<String> с "hello" → альтернатива "hello world"  

### Тест



# Задание 2.3

### Текст задачи
Начало отсчета.  
Создайте метод, принимающий Коробку из задачи 3.1.1, и кладет в неё трехмерную точку  
координат (из задачи 2.1.5) с произвольными значениями. Метод должен позволять передавать  
Коробку с более чем одним видом параметризации.  

### Алгоритм решения  
1. Создаем метод putPointInBox(Box<? super Point3D> box, Point3D point)  
2. В теле просто вызываем box.put(point)  
3. Благодаря wildcard ? super Point3D метод принимает коробки с Point3D, Point2D и Object  
### Тест



# Задание 3.1

### Текст задачи
Функция.  
Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий  
единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть  
новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.  
Используйте разработанный метод следующим образом:  
1. Передайте в метод список со значениями:“qwerty”, “asdfg”, “zx”, а получите список чисел,  
где каждое число соответствует длине каждой строки.  
2. Передайте в метод список со значениями: 1,-3,7, а получите список в котором все  
отрицательные числа стали положительными, а положительные остались без изменений  
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в  
котором будут только максимальные значения каждого из исходных массивов  

### Алгоритм решения
1. Создаем обобщенный метод <T, R> List<R> map(List<T> list, Function<T, R> function)  
2. Создаем пустой список-результат  
3. Для каждого элемента применяем функцию и добавляем результат в новый список  
4. Возвращаем новый список  
5. Демонстрация: строки → длины чисел, числа → модули, массивы → максимумы  
### Тест




# Задание 3.2

### Текст задачи
Фильтр.  
Разработайте такой метод, который будет принимать список значений типа T и объект имеющий  
единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из  
которого удалены все значения не прошедшие проверку условием.  
Используйте разработанный метод следующим образом:  
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и отфильтруйте все  
строки имеющие менее трех символов  
2. Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные  
элементы  
3. Передайте в метод список состоящий из массивов целых чисел, а получите список в  
котором будут только те массивы, в которых нет ни одного положительного элемента  

### Алгоритм решения
1. Создаем обобщенный метод <T> List<T> filter(List<T> list, Predicate<T> predicate)  
2. Создаем пустой список-результат  
3. Для каждого элемента проверяем условие, если true - добавляем в результат  
4. Возвращаем отфильтрованный список  
5. Демонстрация: фильтр строк по длине, фильтр положительных чисел,  
фильтр массивов без положительных  

### Тест



# Задание 3.3

### Текст задачи
Сокращение.  
Разработайте такой метод, который будет принимать список значений типа T и способ с помощью  
которого список значений можно свести к одному значению типа T, которое и возвращается из  
метода.  
Используйте разработанный метод следующим образом:  
1. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, и сформируйте одну  
большую строку, которая состоит из всех строк исходного списка.  
2. Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного  
списка.  
3. Имеется список, состоящий из списков целых чисел, получите общеe количество  
элементов во всех списках. Подсказка: решить задачу можно в одно действие или  
последовательно использовать методы из 3.3.1 и 3.3.3.  
Далее необходимо изменить разработанный метод таким образом, чтобы данный метод  
гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список  
пуст.  

### Алгоритм решения
1. Создаем обобщенный метод <T> T reduce(List<T> list, BinaryOperator<T> operator, T identity)
2. Инициализируем результат значением identity
3. Последовательно применяем оператор к результату и каждому элементу
4. Возвращаем итоговое значение (гарантированно не null благодаря identity)
5. Демонстрация: конкатенация строк, сумма чисел, общее количество элементов во вложенных списках

### Тест




# Задание 3.4


### Текст задачи 
Коллекционирование.  
Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T.  
Данный метод будет принимать:  
1. Список исходных значений  
2. Способ создания результирующей коллекции  
3. Способ передачи значений исходного списка в результирующую коллекцию.  
Используйте разработанный метод следующим образом:  
1. Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два  
подсписка, в одном из которых будут только положительные числа, а в другом только  
отрицательные.  
2. Передайте в метод список со значениями: “qwerty”, “asdfg”, “zx”, “qw” и верните их  
разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только  
одинаковой длины  
3. Передайте в метод список со значениями: “qwerty”, “asdfg”, “qwerty”, “qw” и верните набор  
такого вида, который не может содержать одинаковые объекты.  

### Алгоритм решения
partitionBy:  
- Создаем метод <T> Map<Boolean, List<T>> partitionBy(List<T> list, Predicate<T> predicate)   
- Создаем HashMap с двумя ключами true и false и пустыми списками  
- Для каждого элемента определяем ключ по предикату и добавляем в соответствующий список  
groupBy:  
- Создаем метод <T, K> Map<K, List<T>> groupBy(List<T> list, Function<T, K> classifier)  
- Создаем пустой HashMap  
- Для каждого элемента получаем ключ через классификатор  
- Используем computeIfAbsent для создания списка при необходимости и добавляем элемент  
collectToCollection:  
- Создаем метод <T, C extends Collection<T>> C collectToCollection(List<T> list,  
Supplier<C> supplier)  
- Создаем коллекцию через supplier  
- Добавляем все элементы списка в коллекцию  
- Возвращаем коллекцию  
Демонстрация: разбиение на положительные/отрицательные, группировка строк по длине,  
сбор в Set для уникальных значений  

### Тест
